// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import org.photonvision.PhotonUtils;

import edu.wpi.first.math.util.Units;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.PhotonCameraWrapper;
import frc.robot.commands.driveWithJoystick;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Board extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private DigitalInput limitSwitchOn1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
public PhotonCameraWrapper pcw;
double forwardSpeed;
double rotationSpeed;
    /**
    *
    */
    public Board() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
limitSwitchOn1 = new DigitalInput(1);
 addChild("LimitSwitchOn1", limitSwitchOn1);
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
   pcw = new PhotonCameraWrapper();
   public void drive(double xSpeed, double rot) {
    var wheelSpeeds = m_kinematics.toWheelSpeeds(new ChassisSpeeds(xSpeed, 0.0, rot));
    setSpeeds(wheelSpeeds);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run 
        SmartDashboard.putBoolean("Limit Switch on 0", limitSwitchOn1.get());
        if (pcw.photonCamera.getLatestResult().hasTargets()){
        SmartDashboard.putNumber("Target Existence", pcw.photonCamera.getLatestResult().targets.get(0).getFiducialId());
        }
      
        
        final double CAMERA_HEIGHT_METERS = Units.inchesToMeters(0);
       final double TARGET_HEIGHT_METERS = Units.feetToMeters(CAMERA_HEIGHT_METERS);
       final double CAMERA_PITCH_RADIANS = Units.degreesToRadians(TARGET_HEIGHT_METERS);
       final double GOAL_RANGE_METERS = Units.feetToMeters(CAMERA_PITCH_RADIANS);

       if (driveWithJoystick.buttonOne()) {

        // Vision-alignment mode

        // Query the latest result from PhotonVision

        var result = pcw.photonCamera.getLatestResult();


        if (result.hasTargets()) {

            // First calculate range

            double range =

                    PhotonUtils.calculateDistanceToTargetMeters(

                            CAMERA_HEIGHT_METERS,

                            TARGET_HEIGHT_METERS,

                            CAMERA_PITCH_RADIANS,

                            Units.degreesToRadians(result.getBestTarget().getPitch()));


            // Use this range as the measurement we give to the PID controller.

            // -1.0 required to ensure positive PID controller effort _increases_ range

            forwardSpeed = -forwardController.calculate(range, GOAL_RANGE_METERS);


            // Also calculate angular power

            // -1.0 required to ensure positive PID controller effort _increases_ yaw

            rotationSpeed = -turnController.calculate(result.getBestTarget().getYaw(), 0);

        } else {

            // If we have no targets, stay still.

            forwardSpeed = 0;

            rotationSpeed = 0;

        }

    } else {

        // Manual Driver Mode

        forwardSpeed = -xboxController.getRightY();

        rotationSpeed = xboxController.getLeftX();

    }


    // Use our forward/turn speeds to control the drivetrain

    drive.arcadeDrive(forwardSpeed, rotationSpeed);

}
        // Units.degreesToRadians(result.getBestTarget.getYaw());

        }
        // SmartDashboard.putBoolean("Target Existence", PhotonPipelineResult.hasTargets());

        }
    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}
    

